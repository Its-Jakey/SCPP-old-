#include <graphics>
#include <math>
#include <time>
#include <input>
#include <strings>

#define nodeSize 8
#define FPS 30
#define LIST_SIZE 128

#define screenWidth 480
#define screenHeight 360

#define PI 3.14159265359
#define NEG_PI -3.14159265359

namespace wireList {
    var idx = 0;
    public var values[LIST_SIZE];

    public func add(x, y, z) {
        values[idx] = x;
        values[idx + 1] = y;
        values[idx + 2] = z;
        idx += 3;
    }

    public func get(index) {
        return values[index];
    }

    public func set(index, value) {
        values[index] = value;
    }

    public func size() {
        return idx;
    }
}

namespace test3D {
    public var pointX = 0;
    public var pointY = 0;
    public var fov = PI / 2;
    public var camX = 0;
    public var camY = 0;
    public var camZ = 0;
    public var direction = PI / 8;
    public var speed = 0.1;
    var negSpeed = 0;

    var rPosX = 0;
    var rPosY = 0;
    var rPosZ = 0;
    var rotationY = 0;
    var FPS = 0;

    /*Position pointOnCanvas(Position pos){

        float angleH = atan2(pos.y, pos.x);
        float angleV = atan2(pos.z, pos.x);

        angleH /=abs (cos(angleH));
        angleV /=abs (cos(angleV));

        return new Position(screenWidth/2-angleH*screenWidth/fov, screenHeight/2-angleV*screenWidth/fov, 0);
    } */

    public func pointOnCanvas(x, y, z) {
        var angleH = math::atan2(y, x);
        var angleV = math::atan2(z, x);

        //Uncomment to remove warping (broken)
        //angleH = angleH / math::abs(math::cos(angleH));
        //angleV = angleV / math::abs(math::cos(angleV));

        pointX = screenWidth / 2 - angleH * screenWidth / fov;
        pointY = screenHeight / 2 - angleV * screenWidth / fov;

        //println(pointX, pointY, angleH, angleV);
    }

    public func toCamCoords(x, y, z){
        rPosX = x - camX;
        rPosY = y - camY;
        rPosZ = z - camZ;

        var negDir = math::negate(direction);
        var negRotY = math::negate(rotationY);

        //rotation z-axis
        rPosX = rPosX * math::cos(negDir) - rPosY * math::sin(negDir);
        rPosY = rPosX * math::sin(negDir) + rPosY * math::cos(negDir);

        //rotation y-axis
        rPosX = rPosX * math::cos(negRotY) + rPosZ * math::sin(negRotY);
        rPosZ = rPosZ * math::cos(negRotY) - rPosX * math::sin(negRotY);
    }

    func wire(x0, y0, z0, x1, y1, z1) {
        wireList::add(x0, y0, z0);
        wireList::add(x1, y1, z1);
    }

    public func drawCube3D(x, y, z, size) {
        wire(x, y, z, x + size, y, z);
        wire(x, y + size, y, x + size, y + size, z);
        wire(x, y, z, x, y + size, z);
        wire(x + size, y, z, x + size, y + size, z);
        wire(x, y, z + size, x + size, y, z + size);
        wire(x, y + size, z + size, x + size, y + size, z + size);
        wire(x, y, z + size, x, y + size, z + size);
        wire(x + size, y, z + size, x + size, y + size, z + size);
        wire(x, y, z, x, y, z + size);
        wire(x, y + size, z, x, y + size, z + size);
        wire(x + size, y + size, z, x + size, y + size, z + size);
        wire(x + size, y, z, x + size, y, z + size);

        /*wire(x, y, z, x + size, y, z);
        wire(x, y, z, x, y, z + size);
        wire(x + size, y, z, x + size, y, z + size);
        wire(x, y, z + size, x + size, y, z + size);*/
    }

    var pmouseX = 0;
    var pmouseY = 0;

    public func moveCamera(x, y, z) {
        camX += x;
        camY += y;
        camZ += z;
    }

    public func render() {
        graphics::setColor(255);

        for (i from 0 to wireList::size() by 6) {
            toCamCoords(wireList::values[i], wireList::values[i + 1], wireList::values[i + 2]);
            pointOnCanvas(rPosX, rPosY, rPosZ);
            //pointOnCanvas(wireList::values[i], wireList::values[i + 1], wireList::values[i + 2]);
            //println(wireList::values[i], wireList::values[i + 1], wireList::values[i + 2]);

            var drawStartX = pointX;
            var drawStartY = pointY;
            //println(drawStartX);

            toCamCoords(wireList::values[i + 3], wireList::values[i + 4], wireList::values[i + 5]);
            pointOnCanvas(rPosX, rPosY, rPosZ);
            //pointOnCanvas(wireList::values[i + 3], wireList::values[i + 4], wireList::values[i + 5]);
            graphics::drawLine(drawStartX, drawStartY, pointX, pointY);
        }
    }

    public func drawCrosshare() {
        graphics::setColor(16777215);
        graphics::drawLine(235, 180, 245, 180);
        graphics::drawLine(240, 175, 240, 185);
    }

    func setupScene() {
        drawCube3D(100, 100, 100, 100);
    }


    public func main(){
        negSpeed = math::negate(speed);
        pmouseX = input::mouseX();
        pmouseY = input::mouseY();

        setupScene();

        /*while (1) {
            toCamCoords(input::ask("x"), input::ask("y"), input::ask("z"));
            println(rPosX, rPosY, rPosZ, "------------------");
        }*/

        while (1) {
            var start = time::getRuntimeMillis();


            if (input::isKeyPressed("w")) moveCamera(speed * math::cos(direction), speed * math::sin(direction), 0);
            if (input::isKeyPressed("s")) moveCamera(negSpeed * math::cos(direction), negSpeed * math::sin(direction), 0);
            if (input::isKeyPressed("a")) moveCamera(negSpeed * math::sin(direction), speed * math::cos(direction), 0);
            if (input::isKeyPressed("d")) moveCamera(speed * math::sin(direction), negSpeed * math::cos(direction), 0);

            if (input::isKeyPressed("up arrow")) rotationY += speed;
            if (input::isKeyPressed("down arrow")) rotationY += negSpeed;
            if (input::isKeyPressed("left arrow")) direction += speed;
            if (input::isKeyPressed("right arrow")) direction += negSpeed;

            render();
            drawCrosshare();

            //time::sleep(mspf - (end - start));
            graphics::drawTextLine(strings::join("FPS: ", math::round(FPS, 2)));
            graphics::drawTextLine(strings::join("Direction: ", math::round(direction, 2)));
            graphics::flip();
            graphics::clear();

            var end = time::getRuntimeMillis();
            var frameTime = end - start;
            FPS = (1000 / frameTime);

            }
        }
    }

}

